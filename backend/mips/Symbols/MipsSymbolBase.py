#!/usr/bin/env python3

# SPDX-FileCopyrightText: Â© 2022 Decompollaborate
# SPDX-License-Identifier: MIT

from __future__ import annotations

from ...common.Utils import *
from ...common.GlobalConfig import GlobalConfig
from ...common.Context import Context, ContextSymbolBase, ContextSymbol, ContextOffsetSymbol
from ...common.FileSectionType import FileSectionType

from ..MipsElementBase import ElementBase


class SymbolBase(ElementBase):
    def __init__(self, context: Context, inFileOffset: int, vram: int|None, name: str, words: list[int]=[]):
        super().__init__(context, inFileOffset, vram, name, words)

        self.endOfLineComment = ""

        self.contextSym: ContextSymbol|None = None
        if self.vram is not None:
            self.contextSym = self.context.getAnySymbol(self.vram)

    def generateAsmLineComment(self, localOffset: int, wordValue: int|None = None) -> str:
        if not GlobalConfig.ASM_COMMENT:
            return ""
        offsetHex = f"{localOffset + self.inFileOffset + self.commentOffset:06X}"

        vramHex = ""
        if self.vram is not None:
            currentVram = self.getVramOffset(localOffset)
            vramHex = f"{currentVram:08X} "

        wordValueHex = ""
        if wordValue is not None:
            wordValueHex = f"{wordValue:08X} "

        return f"/* {offsetHex} {vramHex}{wordValueHex}*/"

    def getSymbolAtVramOrOffset(self, localOffset: int) -> ContextSymbolBase | None:
        if self.vram is not None:
            currentVram = self.getVramOffset(localOffset)
            return self.context.getAnySymbol(currentVram)
        return self.context.getOffsetSymbol(self.inFileOffset + localOffset, self.sectionType)

    def getLabel(self) -> str:
        if self.contextSym is not None:
            return self.contextSym.getSymbolLabel() + "\n"
        else:
            offsetSym = self.context.getOffsetSymbol(self.inFileOffset, self.sectionType)
            if offsetSym is not None:
                return offsetSym.getSymbolLabel() + "\n"
        return ""


    def renameBasedOnSection(self):
        if not GlobalConfig.AUTOGENERATED_NAMES_BASED_ON_SECTION_TYPE:
            return

        if self.sectionType != FileSectionType.Rodata and self.sectionType != FileSectionType.Bss:
            return

        if self.vram is None:
            return

        if self.contextSym is not None:
            if not self.contextSym.isAutogenerated:
                return

            if self.sectionType == FileSectionType.Rodata:
                if self.contextSym.type != "@jumptable":
                    self.contextSym.name = f"R_{self.vram:08X}"
            elif self.sectionType == FileSectionType.Bss:
                self.contextSym.name = f"B_{self.vram:08X}"
            self.name = self.contextSym.name

    def renameBasedOnType(self):
        pass


    def analyze(self):
        self.renameBasedOnSection()
        self.renameBasedOnType()


    def disassembleAsData(self) -> str:
        output = self.getLabel()

        localOffset = 0

        for w in self.words:
            label = ""
            if localOffset != 0:
                # Possible symbols in the middle
                contextSym = self.getSymbolAtVramOrOffset(localOffset)
                if contextSym is not None:
                    label = "\n" + contextSym.getSymbolLabel() + "\n"

            value = f"0x{w:08X}"

            # .elf relocated symbol
            possibleReference = self.context.getRelocSymbol(self.inFileOffset + localOffset, self.sectionType)
            if possibleReference is not None:
                value = possibleReference.getNamePlusOffset(w)

            # This word could be a reference to a symbol
            symbol = self.context.getAnySymbol(w)
            if symbol is not None:
                value = symbol.name

            comment = self.generateAsmLineComment(localOffset)
            output += f"{label}{comment} .word {value}" + self.endOfLineComment + "\n"
            localOffset += 4

        return output


    def disassemble(self) -> str:
        return self.disassembleAsData()
