/* SPDX-FileCopyrightText: Â© 2025 Decompollaborate */
/* SPDX-License-Identifier: MIT */

use alloc::sync::Arc;
use core::{fmt, hash::Hash};

use crate::{
    addresses::{Rom, Vram},
    collections::{unordered_map::UnorderedMap, unordered_set::UnorderedSet},
    parent_segment_info::ParentSegmentInfo,
};

use super::{GeneratedBy, LabelMetadataNameDisplay, LabelType, OwnerSegmentKind, ReferencedInfo};

#[derive(Clone)]
#[allow(dead_code)]
pub struct LabelMetadata {
    generated_by: GeneratedBy,
    vram: Vram,
    owner_segment_kind: OwnerSegmentKind,
    autodetected_type: LabelType,

    rom: Option<Rom>,

    user_declared_name: Option<Arc<str>>,
    user_declared_type: Option<LabelType>,

    is_defined: bool,

    /// Which functions reference this label.
    /// Key is the vram of the function and the segment it is contained on (since vrams can overlap
    /// on different segments).
    /// Value is the rom of the instruction that references this symbol, so we can know how many
    /// times a function references the same label.
    reference_functions: UnorderedMap<(Vram, ParentSegmentInfo), UnorderedSet<Rom>>,
    /// Which symbols reference this label.
    /// Key is the vram of the non-function symbol and the segment it is contained on (since vrams
    /// can overlap on different segments).
    /// Value is the rom of the word that references this symbol, so we can know how many
    /// times a symbol references the same label.
    reference_symbols: UnorderedMap<(Vram, ParentSegmentInfo), UnorderedSet<Rom>>,

    visibility: Option<Arc<str>>,
}

impl LabelMetadata {
    pub(crate) fn new(
        vram: Vram,
        owner_segment_kind: OwnerSegmentKind,
        label_type: LabelType,
    ) -> Self {
        Self {
            generated_by: GeneratedBy::Autogenerated,
            vram,
            owner_segment_kind,
            autodetected_type: label_type,

            rom: None,

            user_declared_name: None,
            user_declared_type: None,

            is_defined: false,

            reference_functions: UnorderedMap::new(),
            reference_symbols: UnorderedMap::new(),

            visibility: None,
        }
    }

    pub(crate) fn new_user(
        vram: Vram,
        owner_segment_kind: OwnerSegmentKind,
        label_type: LabelType,
        name: Arc<str>,
        rom: Option<Rom>,
    ) -> Self {
        Self {
            generated_by: GeneratedBy::UserDeclared,

            rom,

            user_declared_name: Some(name),
            user_declared_type: Some(label_type),

            ..Self::new(vram, owner_segment_kind, label_type)
        }
    }

    pub fn generated_by(&self) -> GeneratedBy {
        self.generated_by
    }

    pub const fn vram(&self) -> Vram {
        self.vram
    }

    pub fn label_type(&self) -> LabelType {
        self.user_declared_type.unwrap_or(self.autodetected_type)
    }
    pub(crate) fn set_autodetected_type(&mut self, new_type: LabelType) {
        if self.autodetected_type.does_new_takes_precedence(new_type) {
            self.autodetected_type = new_type;
        }
    }

    pub fn owner_segment_kind(&self) -> &OwnerSegmentKind {
        &self.owner_segment_kind
    }

    pub fn rom(&self) -> Option<Rom> {
        self.rom
    }
    pub(crate) fn set_rom(&mut self, new_rom: Rom) {
        self.rom = Some(new_rom);
    }

    pub fn display_name(&self) -> LabelMetadataNameDisplay {
        LabelMetadataNameDisplay::new(self)
    }
    pub(crate) fn user_declared_name(&self) -> Option<Arc<str>> {
        self.user_declared_name.clone()
    }
    #[cfg(feature = "pyo3")]
    pub(crate) fn set_user_declared_name(&mut self, name: Arc<str>) {
        self.user_declared_name = Some(name);
    }

    pub fn is_defined(&self) -> bool {
        self.is_defined
    }
    pub(crate) fn set_defined(&mut self) {
        self.is_defined = true;
    }

    /// How much this label is referenced by something else
    pub fn reference_counter(&self) -> usize {
        self.reference_functions.values().count() + self.reference_symbols.values().count()
    }
    pub(crate) fn set_referenced_info(&mut self, info: ReferencedInfo) {
        match info {
            ReferencedInfo::Function {
                sym_vram,
                parent,
                specific_rom,
            } => {
                self.reference_functions
                    .entry((sym_vram, parent))
                    .or_default()
                    .insert(specific_rom);
            }
            ReferencedInfo::Data {
                sym_vram,
                parent,
                specific_rom,
            } => {
                self.reference_symbols
                    .entry((sym_vram, parent))
                    .or_default()
                    .insert(specific_rom);
            }
        }
    }

    pub fn visibility(&self) -> Option<Arc<str>> {
        self.visibility.clone()
    }
}

impl PartialEq for LabelMetadata {
    fn eq(&self, other: &Self) -> bool {
        self.vram == other.vram && self.rom == other.rom
    }
}
impl PartialOrd for LabelMetadata {
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.vram.partial_cmp(&other.vram) {
            Some(core::cmp::Ordering::Equal) => {}
            ord => return ord,
        };
        self.rom.partial_cmp(&other.rom)
    }
}
impl Hash for LabelMetadata {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        self.vram.hash(state);
        self.rom.hash(state);
    }
}

impl fmt::Debug for LabelMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "LabelMetadata {{ vram: 0x{}, name: \"{}\" }}",
            self.vram,
            self.display_name()
        )
    }
}
